#print_length 1000;;
#print_depth 1000;;
#directory "_build/lib"
#load "_build/lib/words.cmo";;

open JavaScript
open JavaScript_syntax

let dbgerr = ref ""

let parse path =
    (let fd = open_in path in try 
       let rslt = parse_javascript_from_channel fd path in
       close_in fd;
       rslt
     with exn ->
      (close_in fd;
       let err = Printexc.to_string exn in
       dbgerr := err;
       let a,b,c,d = try Scanf.sscanf err "Failure(%[^:]:%d:%d-%d" (fun a b c d -> (a,b,c,d)) with _ -> err,0,0,0 in
       JavaScript_syntax.Prog
         (({Lexing.pos_fname = path; pos_lnum = b; pos_bol = c; pos_cnum = d},
           {Lexing.pos_fname = a; pos_lnum = b; pos_bol = c; pos_cnum = d},
         false),[])))

(*  -e 's=}=;}=g' -e 's=;\\(})[^,]\\)=\\1=g' *)
(*
let parse' ix path = print_endline (string_of_int ix);
  if Sys.command("../node_modules/.bin/js-beautify "^path^" | sed -e 's=\206\148=delta_=g' -e 's=\207\136=psy_=g' -e 's=\206\169=omega_=g' -e 's=\206\181=epsilon_=g' -e 's=\207\129=rho_=g' -e 's=\207\131=sigma_=g' -e 's=\207\132=tau_=g' > js"^string_of_int ix^".js") = 1 then
  Sys.command("js-beautify "^path^" > js"^string_of_int ix^".js")
  else 1
*)

let crnt' () = 
  let dir = Unix.opendir "." in
  let lst = ref [] in
  (try while true do let str = Unix.readdir dir in let len = String.length str in if len > 3 && String.sub str (String.length str - 3) 3 = ".js" then lst := str :: !lst; done;
  with e -> Unix.closedir dir);
  List.sort compare !lst

let rslt' lst = 
  List.map parse lst

let friendtab = Hashtbl.create 65535
let ftab = Hashtbl.create 65535

let fr id =
  if Hashtbl.mem friendtab id then
    Hashtbl.find friendtab id
  else
    let ix = Hashtbl.hash id in
    let str = if String.length id > 3 && String.sub id 0 3 = "_0x" then Hashtbl.find Words.h (ix mod (Hashtbl.length Words.h)) else id in
    let _ = Hashtbl.add friendtab id str in
    str

let travconst = function
  | CString(string) -> "'"^string^"'"
  | CRegexp(string, bool, bool') -> "regexp"
  | CNum(float) -> string_of_float float
  | CInt(int) -> string_of_int int
  | CBool(bool) -> string_of_bool bool
  | CNull -> "null"
  | CUndefined -> "undefined"

let dbgexpr = ref None
let verbose = ref false

let travunary = function
  | PrefixInc -> "++"
  | PrefixDec -> "--"
  | PostfixInc -> "++"
  | PostfixDec -> "--"

let travinfix = function
  | OpLT -> "<"
  | OpLEq  -> "<="
  | OpGT  -> ">"
  | OpGEq   -> ">="
  | OpIn -> "In"
  | OpInstanceof -> "Of"
  | OpEq -> "=="
  | OpNEq -> "!="
  | OpStrictEq -> "=="
  | OpStrictNEq -> "!=="
  | OpLAnd -> "&&"
  | OpLOr  -> "||"
  | OpMul -> "*"
  | OpDiv -> "/"
  | OpMod -> "%"
  | OpSub -> "-"
  | OpLShift -> ">>"
  | OpSpRShift -> "<<"
  | OpZfRShift -> "<<"
  | OpBAnd -> "&"
  | OpBXor -> "^"
  | OpBOr -> "|"
  | OpAdd -> "+"

let travprefix = function
  | PrefixLNot -> "~"
  | PrefixBNot -> "!"
  | PrefixPlus -> "+"
  | PrefixMinus -> "-"
  | PrefixTypeof -> "Typeof "
  | PrefixVoid -> "Void "
  | PrefixDelete -> "Delete "

let rec travexpr ind = function
  | ConstExpr(pos_t, const) -> (* if !verbose then print_endline (ind^"ConstExpr"); *) travconst const
  | ArrayExpr(pos_t, expr_lst) -> (* if !verbose then print_endline (ind^"ArrayExpr"); *) "["^String.concat "; " (List.map (travexpr ("  "^ind)) (expr_lst))^"]"
  | ObjectExpr(pos_t, lst) -> if !verbose then print_endline (ind^"ObjectExpr"); String.concat " " (List.map (fun (pos_t, prop, expr) -> "") lst)
  | ThisExpr(pos_t) -> if !verbose then print_endline (ind^"ThisExpr"); "this"
  | VarExpr(pos_t, id) -> if !verbose then print_endline (ind^"VarExpr"); fr id
  | DotExpr(pos_t, expr, id) -> if !verbose then print_endline (ind^"DotExpr"); travexpr ind expr ^ "." ^ fr id
  | BracketExpr(pos_t, expr, expr') -> if !verbose then print_endline (ind^"BracketExpr"); travexpr ind expr ^ travexpr ind expr'
  | NewExpr(pos_t, expr, expr_lst) -> if !verbose then print_endline (ind^"NewExpr"); String.concat " " (List.map (travexpr ind) (expr::expr_lst))
  | PrefixExpr(pos_t, prefixOp, expr) -> if !verbose then print_endline (ind^"PrefixExpr"); travprefix prefixOp ^ travexpr ind expr
  | UnaryAssignExpr(pos_t, unaryAssignOp, lvalue) -> if !verbose then print_endline (ind^"UnaryAssignExpr"); travunary unaryAssignOp ^ travlvalue ind lvalue
  | InfixExpr(pos_t, infixOp, expr, expr') -> if !verbose then print_endline (ind^"InfixExpr"); travexpr ind expr ^ travinfix infixOp ^ travexpr ind expr'
  | IfExpr(pos_t, expr, expr', expr'') -> if !verbose then print_endline (ind^"IfExpr"); (travexpr ind expr^" "^travexpr ind expr'^" "^travexpr ind expr'')
  | AssignExpr(pos_t, assignOp, lvalue, expr) -> if !verbose then print_endline (ind^"AssignExpr"); travlvalue ind lvalue^travexpr ind expr
  | ParenExpr(pos_t, expr) -> if !verbose then print_endline (ind^"ParenExpr"); "("^travexpr ind expr^")"
  | ListExpr(pos_t, expr, expr') -> if !verbose then print_endline (ind^"ListExpr"); (travexpr ind expr^" "^travexpr ind expr')
  | CallExpr(pos_t, expr, expr_lst) -> if !verbose then print_endline (ind^"CallExpr"); String.concat " " (List.map (travexpr ind) (expr::expr_lst))
  | FuncExpr(pos_t, id_lst, stmt) -> if !verbose then print_endline (ind^"FuncExpr"); String.concat ", " (List.map fr id_lst)^" "^travstmt ind stmt
  | NamedFuncExpr(pos_t, id, id_lst, stmt) -> if !verbose then print_endline (ind^"NamedFuncExpr"); ""

and travlvalue ind = function
  | VarLValue(pos_t, id) -> fr id
  | DotLValue(pos_t, expr, id) -> travexpr ind expr ^ "." ^ fr id
  | BracketLValue(pos_t, expr, expr') -> travexpr ind expr ^ " " ^ travexpr ind expr'

and varDecl ind = function
  | VarDeclNoInit (pos_t, id) -> (ind^fr id)
  | VarDecl (pos_t, id, expr) -> (ind^fr id^" = "^travexpr ind expr)

and travstmt ind = function
  | BlockStmt(pos_t, stmt_lst) -> if !verbose then print_endline (ind^"BlockStmt"); String.concat "; " (List.map (travstmt ("  "^ind)) stmt_lst)
  | EmptyStmt(pos_t  ) -> (ind^"EmptyStmt")
  | ExprStmt(expr) -> travexpr ind expr
  | IfStmt(pos_t, expr, stmt, stmt') -> (ind^"IfStmt") ^ travstmt ("  "^ind) stmt ^ travstmt ("  "^ind) stmt'
  | IfSingleStmt(pos_t, expr, stmt) -> (ind^"IfSingleStmt") ^ travstmt ("  "^ind) stmt
  | SwitchStmt(pos_t, expr, caseClause_lst) -> (ind^"SwitchStmt")
  | WhileStmt(pos_t, expr, stmt) -> (ind^"WhileStmt") ^ travstmt ("  "^ind) stmt
  | DoWhileStmt(pos_t, stmt, expr) -> (ind^"DoWhileStmt") ^ travstmt ("  "^ind) stmt
  | BreakStmt(pos_t) -> (ind^"BreakStmt")
  | BreakToStmt(pos_t, id) -> (ind^"BreakToStmt")
  | ContinueStmt(pos_t) -> (ind^"ContinueStmt")
  | ContinueToStmt(pos_t, id) -> (ind^"ContinueToStmt")
  | LabelledStmt(pos_t, id, stmt) -> (ind^"LabelledStmt") ^ travstmt ("  "^ind) stmt
  | ForInStmt(pos_t, forInInit, expr, stmt) -> (ind^"ForInStmt") ^ travstmt ("  "^ind) stmt
  | ForStmt(pos_t, forInit, expr, expr', stmt) -> (ind^"ForStmt") ^ travstmt ("  "^ind) stmt
  | TryStmt(pos_t, stmt, catch_lst, stmt') -> (ind^"try {") ^ travstmt ("  "^ind) stmt ^ travstmt ("  "^ind) stmt'^" } "
  | ThrowStmt(pos_t, expr) -> (ind^"ThrowStmt")
  | ReturnStmt(pos_t, expr) -> (ind^"ReturnStmt")
  | WithStmt(pos_t, expr, stmt) -> (ind^"WithStmt") ^ travstmt ("  "^ind) stmt
  | VarDeclStmt(pos_t, varDecl_lst) -> (ind^"var ")^ String.concat ", " (List.map (varDecl ("  "^ind)) varDecl_lst)
  | FuncStmt(pos_t, id, id_lst, stmt) as f -> let id' = fr id in Hashtbl.add ftab id' f; (ind^"function "^id'^" {\n") ^ travstmt ("  "^ind) stmt^" } "
  
let traverse = function
  | Prog (pos,lst) -> String.concat ";\n" (List.map (travstmt "") lst)

let find' () =
  let lst = ref [] in
  let pipe = Unix.open_process_in "find ../2.12.1/rootfs/usr/lib/node/prod -name \\*.js -type f" in
  let _ = try while true do lst := input_line pipe :: !lst done with _ -> ignore (Unix.close_process_in pipe) in
  let lst = List.sort compare !lst in
(*
  List.mapi parse' lst
*)
  List.map parse lst

let dump' ast = List.map (fun itm -> (traverse itm), itm) ast;;

let split' dump =
  List.partition (function "",_ -> false | _ -> true) dump

let iname = function "", JavaScript_syntax.Prog (({pos_fname = path}, _, _),[]) -> path | _ -> ""

let valid',invalid' = split' (dump' (find'()));;

let _ = print_endline ("valid = "^string_of_int (List.length valid')^", invalid = "^string_of_int (List.length invalid'));;
